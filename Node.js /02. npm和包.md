# 1. 包
## 1.1 什么是包
Node.js中的**第三方模块**又叫做**包**。  
就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。  

## 1.2 包的来源
不同于Node.js中的 内置模块与自定义模块，**包是由第三方个人或团队开发出来的**，免费供所有人使用。  

## 1.3 为什么需要包
由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时候，效率很低  
**包是基于内置模块封装出来的**，提供了更高级、更方便的API，极大提高了开发效率。  

## 1.4 如何下载包
npm, Inc.公司提供了一个包管理工具，我们可以使用这个包管理工具，从https://registry.npmjs.org/服务器把需要的包下载到本地使用。  
这个包管理工具的名字叫做**Node Package Manager(简称npm包管理工具)**，这个包管理工具随着Node.js的安装包一起被安装到用户的电脑上。  

## 1.5 npm初次装包后的文件
node_modules文件夹用来**存放所有已安装到项目中的包**。require()导入第三方包时，就是从这个目录中查找并加载包。  
package-lock.json配置文件用来**记录node_modules目录下的每一个包的下载信息**，例如包的名字、版本号、下载地址等。  

## 1.6 安装指定版本的包
默认情况下，使用npm install命令安装包的时候，**会自动安装最新版本的包**。如果需要安装指定版本的包，可以在包名之后，通过**@符号**指定具体版本，例如：
```node
npm i moment@2.22.2
```

## 1.7 包的语义化版本规范
包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.22.2  
其中每一个数字所代表的含义如下：  
第1位数字：大版本  
第2位数字：功能版本  
第3位数字：Bug修复版本


## 1.8 包管理配置文件
### 1.8.1 快速创建package.json
npm包管理工具提供了一个**快捷命令**，可以在**执行命令时所处的目录中**，快速创建package.json这个包管理配置文件：
```node
npm init -y
```
注意：
1. 上述命令**只能在英文的目录下成功运行**！所以，项目文件夹的名称一定要使用英文命名，**不要使用中文，不能出现空格**
2. 运行npm install命令安装包的时候，npm包管理工具会自动把**包的名称**和**版本号**，记录到package.json中
 
### 1.8.2 dependencies节点
package.json文件中，有一个**dependencies节点**，专门用来记录您使用npm install命令安装了哪些包。
<img width="475" alt="image" src="https://github.com/user-attachments/assets/f114aec9-5906-40ec-a552-040680747228">

### 1.8.3 一次性安装所有的包
可以运行**npm install命令（或npm i）**一次性安装所有的依赖包：  
```node
// 执行 npm install 命令时，npm包管理工具会先读取 package.json 中的dependencies节点
// 读取到记录的所有依赖包名称和版本之后，npm 包管理工具会把这些包一次性下载到项目中
npm install
```

### 1.8.4 卸载包
可以运行 npm uninstall 命令，来卸载指定的包
```node
// 使用 npm uninstall 具体的包名， 来卸载包
npm uninstall moment
```
注意：npm uninstall 命令执行后，会把卸载的包，自动从package.json的dependencies中移除掉。  

### 1.8.5 devDependencies节点
如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到devDependencies节点中。  
与之对应的，如果某些包在**开发**和**项目上线之后**都需要用到，则建议把这些包记录到devDependencies节点中。  

可以使用如下的命令，将包记录到devDependencies节点中：
```
// 安装指定的包，并记录到 devDependencies节点中
npm i 包名 -D
// 注意：上述命令是简写形式，等价于下面完整的写法：
npm install 包名 --sava-dev
```

### 1.8.6 解决下包速度慢的问题
为了更方便切换下包的镜像源，我们可以安装`nrm`这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源
```
// 通过 npm 包管理器，将 nrm 安装为全局可用的工具
npm i nrm -g
// 查看所有可用的镜像源
nrm ls
// 将下包的镜像源切换为 taobao镜像
nrm use taobao
```

## 1.9 包的分类
### 1.9.1 项目包
那些被安装到**项目**的node_modules目录中的包，都是项目包  
项目包又分为两类，分别是：
 - 开发依赖包（被记录到`devDependencies`节点中的包，只在开发期间会用到）
 - 核心依赖包（被记录到`dependencies`节点中的包，在开发期间和项目上线之后会用到）
```node
npm i 包名 -D  # 开发依赖包（会被记录到devDependencies节点下）
npm i 包名     # 核心依赖包（会被记录到`dependencies`节点下）
```

### 1.9.2。全局包
在执行npm install命令时，如果提供了`-g`参数，则会把安装为**全局包**。  
```node
npm i 包名 -g            # 全局安装指定的包
npm uninstall 包名 -g    # 卸载全局安装的包
```
注意：
 - 只有工具性质的包，才有全局安装的必要性。因此它们提供了好用的终端命令
 - 判断某个包是否需要全局安装后才能使用，可以**参考官方提供的使用说明**即可。


### 1.9.3 i5ting_toc
i5ting_toc是一个可以把md文档转为html页面的小工具，使用步骤如下：
```node
# 将 i5ting_toc 安装为全局包
npm install -g i5ting_toc
# 调用 i5ting_toc， 轻松实现 md 转 html功能
i5ting_toc -f 要转换的md文件的路径 -o
```

## 2. 模块的加载机制 
##¥ 2.1 优先从缓存中加载
**模块在第一次加载后会被缓存**。这也意味着多次调用require()不会导致模块的代码被执行多次。  
注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而**提高模块的加载效率**。  

## 2.2 内置模块的加载机制
内置模块是由Node.js官方提供的模块，**内置模块的加载优先级最高**。  
例如，require('fs')始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs。  

## 2.3 自定义模块加载
使用require()加载自定义模块时，必须指定以./或../开头的**路径表示符**，在加载自定义模块时，如果没有指定./或../这样的路径标识符，则node会把它当作**内置模块**和**第三方模块**进行加载。  
同时，在使用requier()导入自定义模块时，如果省略了文件的扩展名，则Node.js会按**顺序**分别尝试加载以下的文件：
 1. 按照确切的文件名进行加载
 2. 补全.js扩展名进行加载
 3. 补全.json扩展名进行加载
 4. 补全.node扩展名进行加载
 5. 加载失败，终端报错

 
## 2.4 第三方模块的加载机制 
如果传递给require()的模块标识符不是一个内置模块，也没有以./或../开头，则Node.js会从当前模块的父目录开始，尝试从/node_modules文件夹中加载第三方模块。  
**如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。**  
<img width="1255" alt="image" src="https://github.com/user-attachments/assets/2724bb47-f297-4ef6-b723-9c687aaf25e3">


## 2.5 目录作为模块
当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：
 1. 在被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为require()加载的入口
 2. 如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node.js将会试图加载目录下的index.js文件
 3. 如果以上两步都失败了，则Node.js会在终端打印错误信息，报错模块的缺失：Error：Cannot find module ‘xxx’
