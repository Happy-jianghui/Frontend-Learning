# 1. 深浅拷贝
分为浅拷贝和深拷贝，只针对引用类型

## 1.1 浅拷贝
浅拷贝拷贝的是地址  
**常用方法：**  
1. 拷贝对象：Object.assgin()/展开运算符{...obj}拷贝运算符
   ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/eb320e58-8c94-4f02-a4b5-f51a3df65c2b)
   ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/81f2e078-86c0-4fe2-9c57-c4b64141f719)
3. 拷贝数组：Array.prototype.concat()或者[...arr]
  
但存在问题，如果是简单数据类型拷贝值，引用数据类型拷贝的是地址（如果是单层对象，没问题，如果有多层就有问题）
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/6e9e212e-eaf2-4d31-a8da-5ffa14dee3d3)


## 1.2 深拷贝
深拷贝拷贝的是对象，不是地址
**常见方法：**
1. 通过递归实现拷贝 ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/f071ad6c-35f3-46f9-b990-753aca7535fe)
2. lodash/cloneDeep
3. 通过JSON.stringify()实现


# 2. 异常处理
## 2.1 throw抛异常
异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/c3ab2f22-c71e-49f9-b420-50ac0bca6c67)  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/cba55a42-4e9e-480a-b31a-c49cbce31401)  

总结：  
1. throw抛出异常信息，程序也终止执行
2. throw后面跟着的是错误提示信息
3. Error对象配合throw使用，能够设置更详细的错误信息


## 2.2 try/catch捕获错误信息
我们可以通过try/catch捕捉错误信息（浏览器提供的错误信息），try试试，catch拦住，finally最后
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/c2d0b603-fc5a-44db-9fef-4366cb9aa890)  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/63c527be-fbf6-4157-a996-dab0cbe6cc26)  

总结：  
1. try...catch用于捕获错误信息
2. 将于股可能发生错误的代码写在try代码段中
3. 如果try代码中出现错误后，会执行catch代码段，并截获到错误信息
4. finally 不挂是否有错误，都会执行


## 2.3 debugger
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/3e6edc8c-5f21-4fc1-b451-1ba92d677e0c)


# 3. 处理this
## 3.1 this指向-普通函数
普通函数的调用方式决定了this的值，即【谁调用this的值就指向谁】  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/260e965d-7c02-4711-8fff-e2bcbf34e0d3)  
普通函数没有明确的调用者时this值为window，严格模式下没有调用者时this的值为undefined  

## 3.2 this指向-箭头函数
箭头函数中的this与普通函数完全不同，也不受调用方式的影响，事实上**箭头函数中并不存在this**  
 1. 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的
 2. 箭头函数中的this引用的就是作用域中的this
 3. 向外层作用域中，一层一层查找this，直到有this的定义
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/f4de6e7c-78c5-460a-bfd6-286cc120b19c)

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/3dca7e74-0526-4c8f-a822-ad5a6444f60b)

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/5f9267e5-58c6-4a40-93fb-15f62dc7fbcc)





















