# 1. 作用域
作用域（scope）规定了变量能否被访问的“范围”，离开了这个“范围”，变量便不能被访问  

## 1.1 局部作用域
局部作用域分为函数域和块作用域  

### 1.1.1 函数作用域
在函数内部声明变量只能在函数内部被访问，外部无法直接访问。  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/877f9ff0-6cd4-43c9-9eca-f97bce0a911a)  
总结：  
 1. 函数内部声明变量，在函数外部无法被访问
 2. 函数的参数也是函数内部的局部变量
 3. 不同函数内部声明的变量无法互相访问
 4. 函数执行完毕后，函数内部的变量实际被清空了

### 1.1.2 块作用域
在JavaScript中使用{}包裹代码成为代码块，代码块内部声明的变量外部将【`有可能`】无法被访问。   
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/6815a204-bc6c-4aa1-80cb-126aaad28c03)  
总结：  
 1. let声明的变量会产生块作用域，var不会产生块作用域
 2. const声明的常量也会产生块作用域
 3. 不同代码块之间的变量无法互相访问
 4. 推荐使用let或const

## 1.2 全局作用域
`<script>标签`和`.js`的【最外层】就是所谓的全局变量作用域，在此声明的变量在函数内部也可以被访问。  
全局作用域中的变量，任何其它作用域都可以被访问  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b18b23d9-8646-4420-bfae-697c4e736dfd)  
注意：  
 1. 为window对象动态添加的属性默认也是全局的，不推荐
 2. 函数中未使用任何关键字声明的变量为全局变量，不推荐
 3. 尽可能少声明全局变量，防止全局变量被污染


## 1.3 作用域链
作用域链本质上是底层的`变量查找机制`。  
 - 在函数被执行时，会`优先查找当前`函数作用域中查找变量
 - 如果当前作用域查不到则会依次`逐级查找父级作用域`直到全局作用域
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/aff78d4e-f898-47c4-b1e5-e0144601c913)

总结：  
 1. 嵌套关系的作用域串联起来形成了作用域链
 2. 相同作用域链中按着从小到大规则查找变量
 3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域


## 1.4 垃圾回收机制
`垃圾回收机制（Garbage Collection）简称GC`  
JS中`内存`的分配和回收都是`自动完成`的，内存在不使用的时候会被`垃圾回收器`自动回收  


### 1.4.1 内存的生命周期
 1. `内存分配`：当我们声明变量、函数、对象的时候。系统会自动为他们分配内存
 2. `内存使用`：即读写内存，也就是使用变量、函数等
 3. `内存回收`：使用完毕，由**垃圾回收器**自动回收不再使用的内存
  
说明：  
 - 全局变浓了一般不会回收（关闭页面回收）
 - 一般情况下**局部变量的值**，不用了，会被自动回收掉
  
内存泄露：  
程序中分配的内存由于某种原因程序**未释放**或**无法释放**叫做**内存泄露**
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/78191f5a-921a-49b2-9a42-f806c346a0a5)

### 1.4.2 引用计数
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/bc3c70d1-913e-4391-bc04-7ede359ade2c)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b6305cb9-7110-41e8-8b6f-d8912be87cbb)

### 1.4.3 标记清除法
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/3d3a7b67-91ce-4c41-8a1e-a0c6b05e012d)


## 1.5 闭包
概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到外层函数的作用域  
简单理解：闭包 = 内层函数 + 外层函数
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b7cc8e56-43a0-472e-8cb7-9c1cfa0aa50c)

闭包作用：  
封闭数据，提供操作，外部也可以访问函数内部的变量  
闭包的基本格式：  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/4679d5fd-89df-4a48-9796-ab9918d000df)

闭包应用：实现数据的私有
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/afb537f3-59ab-4754-810d-bcfe4615031e)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/38bade52-01ae-4e7d-80b3-9ce81b4566ba)
count是个全局变量，很容易被需改  

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/99c3db70-cfae-4ed5-92d4-2bffb0ca7343)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/d471030d-8a1f-4231-b2af-88dc9f6ec99d)
这样实现了数据私有，无法直接修改count



## 1.6 变量提升
变量提升是Javascript中比较`奇怪`的现象，它允许变量声明之前即被访问（仅存在于var声明变量）  
注意：  
1. 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为undefined
3. let/const声明的变量不存在变量提升
4. 变量提升出现在相同作用域中
5. 实际开发中推荐先声明再访问变量
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/19aa9c0d-7df8-40a3-ab38-1bb664a3d59d)

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/79d713c2-74eb-435e-a288-0066770f630a)




## 2. 函数进阶
## 2.1 函数提升
函数提升与变量提升比较类似，是指函数在声明之前即可被调用。  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/acf19968-4420-4506-9713-262b18584175)
总结：  
 1. 函数提升能够使函数调用更灵活
 2. 函数表达式不存在提升的现象
 3. 函数提升出现在相同作用域当中























