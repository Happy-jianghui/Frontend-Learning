# 1. 作用域
作用域（scope）规定了变量能否被访问的“范围”，离开了这个“范围”，变量便不能被访问  

## 1.1 局部作用域
局部作用域分为函数域和块作用域  

### 1.1.1 函数作用域
在函数内部声明变量只能在函数内部被访问，外部无法直接访问。  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/877f9ff0-6cd4-43c9-9eca-f97bce0a911a)  
总结：  
 1. 函数内部声明变量，在函数外部无法被访问
 2. 函数的参数也是函数内部的局部变量
 3. 不同函数内部声明的变量无法互相访问
 4. 函数执行完毕后，函数内部的变量实际被清空了

### 1.1.2 块作用域
在JavaScript中使用{}包裹代码成为代码块，代码块内部声明的变量外部将【`有可能`】无法被访问。   
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/6815a204-bc6c-4aa1-80cb-126aaad28c03)  
总结：  
 1. let声明的变量会产生块作用域，var不会产生块作用域
 2. const声明的常量也会产生块作用域
 3. 不同代码块之间的变量无法互相访问
 4. 推荐使用let或const

## 1.2 全局作用域
`<script>标签`和`.js`的【最外层】就是所谓的全局变量作用域，在此声明的变量在函数内部也可以被访问。  
全局作用域中的变量，任何其它作用域都可以被访问  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b18b23d9-8646-4420-bfae-697c4e736dfd)  
注意：  
 1. 为window对象动态添加的属性默认也是全局的，不推荐
 2. 函数中未使用任何关键字声明的变量为全局变量，不推荐
 3. 尽可能少声明全局变量，防止全局变量被污染


## 1.3 作用域链
作用域链本质上是底层的`变量查找机制`。  
 - 在函数被执行时，会`优先查找当前`函数作用域中查找变量
 - 如果当前作用域查不到则会依次`逐级查找父级作用域`直到全局作用域
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/aff78d4e-f898-47c4-b1e5-e0144601c913)

总结：  
 1. 嵌套关系的作用域串联起来形成了作用域链
 2. 相同作用域链中按着从小到大规则查找变量
 3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域


## 1.4 垃圾回收机制
`垃圾回收机制（Garbage Collection）简称GC`  
JS中`内存`的分配和回收都是`自动完成`的，内存在不使用的时候会被`垃圾回收器`自动回收  


### 1.4.1 内存的生命周期
 1. `内存分配`：当我们声明变量、函数、对象的时候。系统会自动为他们分配内存
 2. `内存使用`：即读写内存，也就是使用变量、函数等
 3. `内存回收`：使用完毕，由**垃圾回收器**自动回收不再使用的内存
  
说明：  
 - 全局变浓了一般不会回收（关闭页面回收）
 - 一般情况下**局部变量的值**，不用了，会被自动回收掉
  
内存泄露：  
程序中分配的内存由于某种原因程序**未释放**或**无法释放**叫做**内存泄露**
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/78191f5a-921a-49b2-9a42-f806c346a0a5)

### 1.4.2 引用计数
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/bc3c70d1-913e-4391-bc04-7ede359ade2c)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b6305cb9-7110-41e8-8b6f-d8912be87cbb)

### 1.4.3 标记清除法
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/3d3a7b67-91ce-4c41-8a1e-a0c6b05e012d)


## 1.5 闭包
概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到外层函数的作用域  
简单理解：闭包 = 内层函数 + 外层函数
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b7cc8e56-43a0-472e-8cb7-9c1cfa0aa50c)

闭包作用：  
封闭数据，提供操作，外部也可以访问函数内部的变量  
闭包的基本格式：  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/4679d5fd-89df-4a48-9796-ab9918d000df)

闭包应用：实现数据的私有
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/afb537f3-59ab-4754-810d-bcfe4615031e)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/38bade52-01ae-4e7d-80b3-9ce81b4566ba)
count是个全局变量，很容易被需改  

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/99c3db70-cfae-4ed5-92d4-2bffb0ca7343)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/d471030d-8a1f-4231-b2af-88dc9f6ec99d)
这样实现了数据私有，无法直接修改count



## 1.6 变量提升
变量提升是Javascript中比较`奇怪`的现象，它允许变量声明之前即被访问（仅存在于var声明变量）  
注意：  
1. 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为undefined
3. let/const声明的变量不存在变量提升
4. 变量提升出现在相同作用域中
5. 实际开发中推荐先声明再访问变量
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/19aa9c0d-7df8-40a3-ab38-1bb664a3d59d)

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/79d713c2-74eb-435e-a288-0066770f630a)




## 2. 函数进阶
## 2.1 函数提升
函数提升与变量提升比较类似，是指函数在声明之前即可被调用。  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/acf19968-4420-4506-9713-262b18584175)
总结：  
 1. 函数提升能够使函数调用更灵活
 2. 函数表达式不存在提升的现象
 3. 函数提升出现在相同作用域当中

## 2.2 函数参数
### 2.2.1 动态参数
`arguments`是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/1bca7ed3-a327-4bdc-a6f1-d8b1a6ce7f6c)

总结：  
 1. arguments是一个伪数组，只存在于函数
 2. arguments的作用时动态获取函数的实参
 3. 可以通过for循环依次得到传递过来的实参

### 2.2.2 剩余参数
剩余参数允许我们将一个不定数量的参数表示为一个数组
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/de561651-1148-4993-baad-ae16ff262921)
 1. `...`是语法符号，置于最末函数形参之前，用于获取**多余**的实参
 2. 借助...获取的剩余实参，是个**真数组**
 ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/72982df0-8f8d-4a88-8d19-8e384ae03255)


### 2.2.3 展开运算符
展开运算符(...)，将一个数组进行展开
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/582d8311-869e-4190-a32f-71edca81940d)
说明：  
 1. 不会修改原数组

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/c1c8692a-94b8-4207-86bc-fb0b0fdf07b6)


## 2.3 箭头函数

### 2.3.1 基本语法
1. 基本写法
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/024c68b5-b7a4-4cc8-b738-7e798dc0fabe)
2. 只有一个参数可以省略小括号
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/ef016afb-bc7b-438f-b8f0-c6329fdaa065)   
3. 如果函数体只有一行代码，可以写到一行上，并且无需写return直接返回值
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/c8d27e6a-1ebb-4e7c-af34-bb19b0d3e107)
4. 加括号的函数体返回对象字面量表达式
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b2d80e55-d213-4d08-a4b0-c9f2a8fda13e)

总结：
 1. 箭头函数属于表达式函数，因此不存在函数提升
 2. 箭头函数只有一个参数时可以省略圆括号()
 3. 箭头函数函数体只有一行代码时可以省略花括号{}，并且自动作为返回值被返回
 4. 加括号的函数体返回对象字面量表达式

### 2.3.2 箭头函数参数
1. 普通函数有arguments动态参数
2. 箭头函数没有arguments动态参数，但有`剩余参数`..args
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/3e5ab808-0311-40bb-88c8-9c62f60cd979)


### 2.3.3 箭头函数this
箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/56f91859-a13b-4fee-bddd-d98e9d8f2912)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/4de2dc51-d20f-4f66-ad37-2cc0bf5f3232)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/703a5d37-deeb-4bdc-a0a1-a8acf8d9ebff)

![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/be6e544e-d90c-4552-b960-3bd4d5bd60ad)
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/bb4bd323-d0a8-47f3-910c-6199a77b6cca)


# 3. 解构赋值
## 3.1 数组解构
数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。  
基本语法1  
 1. 赋值运算符 = 左侧的[]用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
 2. 变量的顺序对应数组单元值的位置依次进行赋值操作
 ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/aaaba8dc-f209-4d74-afbb-794480191e60)
 ![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/a587cc5b-0c98-4156-8235-525360dc3752)
  
基本语法2
典型应用交换两个变量
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/6eae8f2f-fb10-4b01-9080-955862e95f12)  
**注意：js前面必须加分号情况**
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/bc468544-d23e-41d1-b920-7b636cf47b18)
  
**变量多，单元值少的情况：**  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b48ed050-8d91-4d7f-9bc4-5878634cd555)
变量的数量大于单元值时，多余的变量将被赋值为`undefined`   

**变量少，单元值多的情况下：**  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/86db103c-22df-4070-846f-928cbe8f7c46)  

**利用剩余参数解决变量少，单元值多的情况：**
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/b5dd730b-1147-4b41-859d-e3792c97b04f)
剩余参数返回的还是一个数组
  
**防止有undefined传递单元值的情况，可以设置默认值：**  
![image](https://github.com/Happy-jianghui/Frontend-Learning/assets/98568967/aa913a0e-2d34-4a04-bdb9-264019ddd6f8)










































